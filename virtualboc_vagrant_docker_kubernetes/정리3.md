> tmi
>
> > rm -rf /var/run/yum.pid
>
> yum  작동중인거 강제로 멈추기





# Docker

http://pyrasis.com/docker.html

https://www.slideshare.net/pyrasis/docker-fordummies-44424016?from_action=save



## 가상머신

가상화의 예) 인터넷뱅킹사용하려면 activex 설치해야하는데 맥에서 불가

-----------------> 맥에 windows 설치해서 인터넷뱅킹을 작업함



### 가상머신의 장점

미리 구축한 가상 머진 이미지를 **여러 서버에 복사하여 실행**하면 이미지 하나로 서버 여러개 생성 가능

===> 가상화 기술 이용하여 **서버를 임대**해주는 서비스가  **클라우드 서비스**!!!!

---

하드웨어 서버 1대당 1개의 소프트웨어 서버 사용

==> 서버의 성능이 좋아짐

하드웨어 서버 1대당 여러개의 소프트웨어 서버 사용

==> 하드웨어 성능이 남는데 ? 컴퓨터가 노는데?

==> 소프트웨어에 서버 자체(서버,db)를 넣자!

==> 그래도 남는데? 더 많은 서버를 돌릴수 있는데??

==> 하드웨어를 살 수없는 사용자에게 서버 공간을 임대해주자!

---



### 가상머신의 문제점

컴퓨터를 통째로 만들어내다 보니 각종 성능 손실이 발생(느리고 용량 많이 차지함...)

===> 인텔 ,amd가 cpu안에 가상화 기능 넣기 시작(하드웨어에서도 가상화 기능 지원하기 시작)

===> 호스트와 커널 공유하는 반가상화 기술 등장

![image-20200914095224367](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20200914095224367.png)

===> 이미지 파일 안에 os가 포함되어 있어 이미지 용량이 큼 ==> 네트워크로 주고받기엔 부담스러움.. **즉, 배포와 관리 기능 부족!!**



> **도커를 사용하는 이유???**
>
> 가상환경은 용량이 크다
>
> (pc 위에 운영체제부터 새로 설치하기 때문)

==> 도커 container 사용함으로 파일용량이 줄어 배포가 쉽다.

>centos 자체를 하나의 파일로 만들어 놓은 것 ovf,ova 파일== 이미지
>
>이러한 이미지를 저장해놓은 곳 == docker hub
>
>이미지를 실행하는 곳 == container
>



## 도커의 특징

- 복잡한 리눅스 어플리케이션을 컨테이너로 **묶어서 실행**할 수 잇다

- 개발,테스트, 서비스 환경을 **하나로 통일하여 효율적으로 관리**  & 사람들과 **공유**
  - 공유 -> Docker Hub

- immutable하다

> 프로그램을 업그레이드 하지않고, 
>
> 기존 프로그램 삭제하고 수정되어있는 머신으로 설치
>
> (하드웨어 자체가 이미지 파일 , 소프트웨어로 관리)
>
> 예전 거 지워버리고 새로운걸로 바꿔치기
>
> ==> 한번 만들어진 소프트웨어는 변경하지 않는다
>
> ==> immutable하다





# Docker 설치

---

**잘못 되는 경우도 있으니 이전 작업은 스냅샷으로 저장해놓자**

```
# V2 이름으로 스냅샷 생성
C:\HashiCorp\WorkDir> vagrant snapshot save V2		
```

## 방법1. 명령어로 설치

**#1 Docker 설치**

``yum install -y docker``

```
C:\HashiCorp\WorkDir> vagrant ssh
[vagrant@demo html]$ sudo su
[root@demo html]# cd
[root@demo ~]# yum install -y docker
```

**#2 Docker 서비스 기동**

```
[root@demo ~]# systemctl start docker.service
[root@demo ~]# docker version
```



## 방법2. vagrantfile로 설치

- vagrantfile 내용

```
# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure("2") do |config|
  config.vm.box = "ubuntu/bionic64"
  config.vm.hostname = "swarm-manager"
  config.vm.network "private_network", ip: "192.168.111.100"
  config.vm.synced_folder ".", "/vagrant_data", disabled: true
  config.vm.provision "shell", inline: $script
end

$script = <<SCRIPT
  apt update
  apt upgrade
  apt install -y docker.io
  usermod -a -G docker $USER
  service docker restart
  chmod 666 /var/run/docker.sock
SCRIPT
```





## Docker Hub 로그인

``docker login``

 (id : ok2qw66 / pw: dksdpwls14!)

```
[root@demo ~]# docker login
Username: DOCKER_HUB_ID
Password: DOCKER_HUB_PASSWORD
Login Succeeded
```



# Docker 이미지

## 1. 이미지 검색

### 방법1. docker search 명령어 사용

- 이미지 이름이 mysql인 이미지 조회

  ```
  docker search mysql
  ```

- 이미지 이름이 mysql인 이미지중 STAR 상위 5개만 조회

  ```
  root@demo:~# docker search --limit 5 mysql         
  ```

### 방법2. HTTP API 이용

**HTTP API V2**

https://docs.docker.com/registry/spec/api/

- 사용법
  - library : 사용자이름 : 도커허브 사용자 계정
  - mysql : 이미지 이름
  - tags: 태그 이름

``https://hub.docker.com/v2/repositories/library/mysql/tags``



- API 사용해서 이미지 정보 조회

```
root@demo:~# curl https://hub.docker.com/v2/repositories/library/mysql/tags
```

==> 가독성이 나쁨 

- jq 유틸리티 설치

```
root@demo:~# apt install -y jq
root@demo:~# curl https://hub.docker.com/v2/repositories/library/mysql/tags | jq
```

- jq 이용해서 특정 데이터만 추출

```
root@demo:~# curl https://hub.docker.com/v2/repositories/library/mysql/tags | jq '.results[].name'
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  4310    0  4310    0     0   1433      0 --:--:--  0:00:03 --:--:--  1433
"latest"
"8.0.21"
"8.0"
"8"
"5.7.31"
"5.7"
"5.6.49"
"5.6"
"5"
"8.0.20"
```



## 2. 이미지 획득 및 확인

이미지 가져오기 :``docker pull IMAGE_NAME``

이미지 목록 확인: ``docker image ls``

```assembly
[root@demo ~]# docker pull docker.io/centos
Using default tag: latest  --------> 버전지정 안하면 가장 최신버전으로 다운
Trying to pull repository docker.io/library/centos ... ----> docker repo에서 다운
latest: Pulling from docker.io/library/centos
3c72a8ed6814: Pull complete                                                                        Digest: sha256:76d24f3ba3317fa945743bb3746fbaf3a0b752f10b10376960de01da70685fbd
Status: Downloaded newer image for docker.io/centos:latest

# 다운받은 이미지 리스트 확인
[root@demo ~]# docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker.io/centos    latest              0d120b6ccaa8        4 weeks ago         215 MB

```

- 태그를 지정해서 이미지 획득

```assembly
# centos7로 버전 지정해서 다운받기 
[root@demo ~]# docker pull docker.io/centos:centos7
Trying to pull repository docker.io/library/centos ...
centos7: Pulling from docker.io/library/centos
75f829a71a1c: Pull complete                                                                        Digest: sha256:19a79828ca2e505eaee0ff38c2f3fd9901f4826737295157cc5212b7a372cd2b
Status: Downloaded newer image for docker.io/centos:centos7

[root@demo ~]# docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker.io/centos    centos7             7e6257c9f8d8        4 weeks ago         203 MB
docker.io/centos    latest              0d120b6ccaa8        4 weeks ago         215 MB
```



> docker에서 파일 다운받는게 timeout 걸릴때?
>
> => 인터넷 연결이 안되서 다운못받는거...

dns 8.8.8.8 로 설정 

![image-20200915094817913](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20200915094817913.png)







## 3. 이미지 삭제

이미지 한개 삭제 : ``docker image rm -f IMAGE_NAME``

이미지 전체 삭제 : ``docker image  rm -f $(docker iamge ls -q)``

태그가 none인(dangling된) 이미지 삭제 : ``docker image prune``



## 4. 도커 이미지 버전 관리

### 버전 변경

- Dockerfile 생성

```
root@demo:~# cat Dockerfile
FROM busybox
RUN echo "version = 1" > /tmp/version
```

- 이미지 생성 및 push

```
root@demo:~# docker image build -t ok2qw66/basetest:latest

root@demo:~# docker image push ok2qw66/basetest:latest
```

- Dockerfile 수정 후 이미지 push

```
root@demo:~# cat Dockerfile
FROM busybox
RUN echo "version = 2" > /tmp/version
```

```
root@demo:~# docker image build -t ok2qw66/basetest:latest

root@demo:~# docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ok2qw66/basetest    latest              3b70435187f3        3 seconds ago       1.23MB
ok2qw66/basetest    <none>              928ea2d65d07        7 minutes ago       1.23MB
```

===> <none> 생성됨 : 태깅되지 않은 이미지 만들어짐!



### 태깅되지 않은 이미지를 검색 및 태그 붙이기

`` docker image tag``

- 현재 이미지

```
root@demo:~# docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ok2qw66/basetest    latest              3b70435187f3        2 minutes ago       1.23MB
ok2qw66/basetest    <none>              928ea2d65d07        9 minutes ago       1.23MB
example/echo        latest              8b1fb4b7ebed        About an hour ago   750MB
<none>              <none>              639660739473        About an hour ago   750MB
helloworld
```

- 태깅되지 않은 이미지 검색

```
root@demo:~# docker image ls --filter "dangling=true"
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ok2qw66/basetest    <none>              928ea2d65d07        10 minutes ago      1.23MB
<none>              <none>              639660739473        About an hour ago   750MB
```

- 태그 추가

```
root@demo:~# docker image tag 928e ok2qw66/basetest:0.1

root@demo:~# docker image ls -f "dangling=true"
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
<none>              <none>              639660739473        About an hour ago   750MB

root@demo:~# docker image tag $(docker image ls -f "dangling=true" -q) ok2qw66/basetest:0.2
```

```
root@demo:~# docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ok2qw66/basetest    latest              3b70435187f3        8 minutes ago       1.23MB
ok2qw66/basetest    0.1                 928ea2d65d07        16 minutes ago      1.23MB
example/echo        latest              8b1fb4b7ebed        About an hour ago   750MB
ok2qw66/basetest    0.2                 639660739473        About an hour ago   750MB
```



## docker 컨테이너 생명주기

![image-20201002152625215](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201002152625215.png)





# Docker 컨테이너

컨테이너 실행: ``docker run -t -d --name CONTAINER_NAME IMAGE_NAME ``

- -d : detach 백그라운드에서 실행
- -t : tty  가상 tty(콘솔창) 할당 , 출력가능
- -i : interactive  입력 가능
- -rm : 컨테이너 중지되면 자동으로 삭제

## 1. 컨테이너 목록 검색

컨테이너 목록 확인: 

- 실행중인 컨테이너 목록확인 :  ``docker container ls(ps)``
- 중지된 컨테이너 포함 확인 : ``docker container ls -a``

```assembly
# centos7이라는 이름으로 docker.io/centos:centos7 파일을 실행한다 ==> 컨테이너로 실행한다
[root@demo ~]# docker run -t -d --name centos7 docker.io/centos:centos7
61260c982277f41fc52a6331f55f853422d601d0e995e85ac9ff892eed69fc3d

# 실행중인 컨테이너 목록 확인
[root@demo ~]# docker container ls		⇐ 동일 명령어 docker container ps
CONTAINER ID        IMAGE                      COMMAND             CREATED             STATUS              PORTS               NAMES
61260c982277        docker.io/centos:centos7   "/bin/bash"         10 seconds ago      Up 9 seconds                            centos7
```



### 컨테이너 생성에 사용된 이미지로 조회

`` docker container ls --filter "ancestor=IMAGE_NAME"``

컨테이너 ID만 추출 : 

`` docker container ls --filter "ancestor=IMAGE_NAME" -q``

```
root@demo:~# docker container ls --filter "ancestor=example/echo"
CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS               NAMES
c3c6d369d385        example/echo:latest   "go run /echo/main.go"   12 minutes ago      Up 12 minutes                           adoring_swirles
```

### 컨테이너 이름으로 조회

``docker container ls -a --filter "name=CONTAINER_NAME"``

```
root@demo:~# docker container ls -a --filter "name=myecho"
CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS               NAMES
c3c6d369d385        example/echo:latest   "go run /echo/main.go"   2 hours ago         Up 2 hours                              myecho
```

### 종료상태인 컨테이너 조회

``docker container ls -a --filter "status=exited"``



### 출력형식 지정(formatting) : 원하는 정보만 출력

``docker container ls -a --format "{{.ID}} : {{.Command}}"``

- 테이블 형태로 보기 좋게 출력

``docker container ls -a --format "table {{.ID}} : {{.Names}}\t{{.Command}}"``





## 2. 컨테이너 내부에 명령어 실행

명령어 한개만 실행 : ``docker exec CONTAINER_NAME 실행명령어``

컨테이너 내부 접속 : ``docker exec -it CONTAINER_NAME /bin/bash``

컨테이너 내부 접속 & exit 시 컨테이너 중지 :  ``docker contianer attch CONTAINER_NAME``

```assembly
# 컨테이너 내부에 설치되어 있는 CentOS 버전을 확인
[root@demo ~]# docker exec centos7 cat /etc/redhat-release
CentOS Linux release 7.8.2003 (Core)

# /bin/bash 파일을 실행한다 (-it 옵션 : 입출력 가능하게)
[root@demo ~]# docker exec -it centos7 /bin/bash

# 실행 중인 컨테이너 내부로 진입
# 61260c982277  ==== CONTAINER ID를 의미
[root@61260c982277 /]# cat /etc/redhat-release
CentOS Linux release 7.8.2003 (Core)

[root@61260c982277 /]# exit
exit
```

- 우분투 이미지를 이용해 컨테이너를 실행

```assembly
# ubuntu라는 이름으로 docker.io/ubuntu 이미지파일로 컨테이너 실행
# d 옵션 : background로 돌도록 설정
[root@demo ~]# docker run --name ubuntu -td docker.io/ubuntu
Unable to find image 'docker.io/ubuntu:latest' locally
Trying to pull repository docker.io/library/ubuntu ...
latest: Pulling from docker.io/library/ubuntu	
⇐ 로컬 레포지터리에 이미지가 존재하지 않기 때문에 먼저 이미지를 가져와서 실행                
54ee1f796a1e: Pull complete                                                         
f7bfea53ad12: Pull complete                                                               
46d371e02073: Pull complete
b66c17bbf772: Pull complete
Digest: sha256:31dfb10d52ce76c5ca0aa19d10b3e6424b830729e32a89a7c6eee2cda2be67a5
Status: Downloaded newer image for docker.io/ubuntu:latest

# container 실행중인 리스트 확인
[root@demo ~]# docker container ls
CONTAINER ID        IMAGE                      COMMAND             CREATED             STATUS              PORTS               NAMES
61260c982277        docker.io/ubuntu           "/bin/bash"         17 minutes ago      Up 17 minutes                           ubuntu
3e15d90137d0        docker.io/centos:centos7   "/bin/bash"         31 minutes ago      Up 31 minutes                           centos7


# ubuntu라는 이름으로 /bin/bash 실행
[root@demo ~]# docker exec -it ubuntu /bin/bash
# 3e15d90137d0 ==== ubuntu 이름의 CONTAINER ID를 의미
root@3e15d90137d0:/# ls
bin   dev  home  lib32  libx32  mnt  proc  run   srv  tmp  var
boot  etc  lib   lib64  media   opt  root  sbin  sys  usr

# 우분투 버전 확인
root@3e15d90137d0:/# cat /etc/issue
Ubuntu 20.04.1 LTS \n \l

root@3e15d90137d0:/# exit
exit

```

## 3. 컨테이너 정지/재기동

컨테이너 정지 : 

1.``docker container stop CONTAINER_NAME``

2.``docker container stop CONTAINER_ID`` (ID 4글자만 입력가능)

컨테이너 재기동 :  

1.``docker container restart CONTAINER_NAME``

2.``docker container restart CONTAINER_ID``(ID 4글자만 입력가능)

```assembly
# centos7 이라는 이름의 container를 멈춘다 (컨테이너 이름 또는 id 입력하면 됨 : 2글자 이상작성)
[root@demo ~]# docker container stop centos7
centos7

# 실행중인 컨테이너 리스트 확인
[root@demo ~]# docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
d0450c56e21c        docker.io/ubuntu    "/bin/bash"         20 minutes ago      Up 20 minutes                           ubuntu

# 모든 컨테이너 리스트 확인 (정지 상태 컨테이너 포함 조회)
[root@demo ~]# docker container ls -a
CONTAINER ID        IMAGE                      COMMAND             CREATED             STATUS                        PORTS               NAMES
61260c982277        docker.io/ubuntu           "/bin/bash"         20 minutes ago      Up 20 minutes                                     ubuntu
3e15d90137d0        docker.io/centos:centos7   "/bin/bash"         35 minutes ago      Exited (137) 11 seconds ago                       centos7
```

```assembly
# centos7 이라는 이름의 컨테이너를 실행한다
[root@demo ~]# docker container start centos7
centos7

[root@demo ~]# docker container ls
CONTAINER ID        IMAGE                      COMMAND             CREATED             STATUS              PORTS               NAMES
61260c982277        docker.io/ubuntu           "/bin/bash"         23 minutes ago      Up 23 minutes                           ubuntu
3e15d90137d0        docker.io/centos:centos7   "/bin/bash"         37 minutes ago      Up 4 seconds                            centos7
[
```

## 4. 컨테이너 삭제 (이미지 파일을 삭제x)

컨테이너 한개 삭제: ``docker container rm -f CONTAINER_NAME``

중지된 컨테이너 일괄 삭제 : ``docker container prune``

컨테이너 전체 삭제 : ``docker container rm -f $(docker container ls -aq)``

> 이미지 파일 : 클래스(붕어빵 틀)
>
> 컨테이너 : 인스턴스, 객체 (피자붕어빵...생성된 것)

```assembly
# centos7이라는 이름의 컨테이너 삭제
[root@demo ~]# docker container rm -f centos7
centos7

# 모든 컨테이너 조회
[root@demo ~]# docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
d0450c56e21c        docker.io/ubuntu    "/bin/bash"         24 minutes ago      Up 24 minutes                           ubuntu

# 이미지 파일 조회
[root@demo ~]# docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker.io/ubuntu    latest              4e2eef94cd6b        3 weeks ago         73.9 MB
docker.io/centos    centos7             7e6257c9f8d8        4 weeks ago         203 MB
docker.io/centos    latest              0d120b6ccaa8        4 weeks ago         215 MB
```

- 모든 컨테이너 삭제

```assembly
컨테이너의 id 가져오기
[root@demo ~]# docker container ls -a -q
35863b64d8b4
82ed691c6188
45efd8e2910b
ccd4a257d0be
38b130102fed
d0450c56e21c

[root@demo ~]# echo $(docker container ls -a -q)
35863b64d8b4 82ed691c6188 45efd8e2910b ccd4a257d0be 38b130102fed d0450c56e21c

[root@demo ~]# docker container rm -f $(docker container ls -a -q)
35863b64d8b4
82ed691c6188
45efd8e2910b
ccd4a257d0be
38b130102fed
d0450c56e21c

# 컨테이너 모두 삭제 확인
[root@demo ~]# docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
```



### 컨테이너 수동으로 삭제

1. 도커 서비스 중지

   ``$ sudo service docker stop``

2. 컨테이너 파일 확인 및 삭제

   ``$ sudo ls /var/lib/docker/containers``

   ``$ sudo rm -r /var/lib/docker/containers/*CONTAINER_ID*``

3. 도커 서비스 실행

   ``$ sudo service docker start``

   



## 5. -p 옵션으로 포트 포워딩

``docker container run -d -p host_port:container_port IMAGE_NAME``

- 호스트 포트 생략 => 자동으로 임의의 포트 할당

### nginx 컨테이너 기동

```assembly
# 공식 배포 이미지는 docker.io 생략가능
[root@demo ~]# docker pull nginx
Using default tag: latest
Trying to pull repository docker.io/library/nginx ...
latest: Pulling from docker.io/library/nginx
d121f8d1c412: Pull complete
ebd81fc8c071: Pull complete
655316c160af: Pull complete
d15953c0e0f8: Pull complete
2ee525c5c3cc: Pull complete
Digest: sha256:9a1f8ed9e2273e8b3bbcd2e200024adac624c2e5c9b1d420988809f5c0c41a5e
Status: Downloaded newer image for docker.io/nginx:latest
```

```assembly
# 호스트의 8000번 포트를 내부의 80 포트로 연결
[root@demo ~]# docker container run -d -p 8000:80 --name nginx-latest nginx
# 컨테이너 id
38b130102fed8409032495286f3ba36cc8a30c511c04e15c7c113dfa6b5a9e65


# 위에서 명시된 container id에서 12자리만 보여줌....38b130102fed
# 0.0.0.0:8000->80/tcp : host 8000번포트를 내부 80번포트로 연결
[root@demo ~]# docker container ls -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
38b130102fed        nginx               "/docker-entrypoin..."   22 seconds ago      Up 21 seconds       0.0.0.0:8000->80/tcp   nginx-latest
d0450c56e21c        docker.io/ubuntu    "/bin/bash"              32 minutes ago      Up 32 minutes                              ubuntu
```

--> localhost : vagrant로 생성한 CentOS (여기서 Host PC가 vagrant이다)

--> 8000번 포트 연결 => nginx 컨테이너의 80번 포트로 mapping

```html
[root@demo ~]# uname -a   ===> 현재 vagrant로 접속중
Linux demo 3.10.0-1127.18.2.el7.x86_64 #1 SMP Sun Jul 26 15:27:06 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux

# nginx 컨테이너 내부의 nginx 웹 루트 디렉터리에 있는 
# index.html 파일의 내용이 보이고 있음
[root@demo ~]# curl http://localhost:8000
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

> 내pc에서도 컨테이너 내부의 nginx를 볼 수 있을까?
>
> **YES**

```
http://192.168.33.10:8000/ 호출하면 됨
===> 192.168.33.10 : vagrant 외부에서 접속하는 ip
===> 192.168.33.10:8000 : vagrant 8000포트로 접속 ==> container 80포트로 연결
```

#### 

### 호스트 포트 랜덤 지정

``-P``: 호스트 포트 랜덤 지정 & expose로 명시된 포트로 바인딩

```
root@demo:~# docker container run -d -P --name mywebrandport myanjini/myweb:dockerfile
```

- 0.0.0.0:32770->80/tcp			

  32770(호스트 포트 : 랜덤지정)  => 80 포트 (명시된 포트)

#### 포트만 확인

``docker port CONTAINER_NAME``

```
root@demo:~# docker port mywebrandport
80/tcp -> 0.0.0.0:32770
```





## 6. 호스트  <-> 컨테이너 내부 파일 복사



### 호스트 파일을 컨테이너 내부로 복사

``docker container cp HOST_PATH CONTAINER_NAME:CONTAINER_PATH``

- main.go 파일을 컨테이너 내부 /tmp 로 복사

```
root@demo:~# ls
Dockerfile  main.go

root@demo:~# docker container ls --format "{{.Names}}"
adoring_swirles

root@demo:~# docker container cp main.go adoring_swirles:/tmp/
```

- 컨테이너 내부에서 복사된 main.go 파일 확인

```
root@demo:~# docker exec -it adoring_swirles /bin/bash
root@c3c6d369d385:/go# cd /tmp/
root@c3c6d369d385:/tmp# ls
go-build162410975  go-build850054578  main.go
```



### 컨테이너 파일을 호스트로 복사

``docker container cp CONTAINER_NAME:CONTAINER_PATH HOST_PATH``

- 컨테이너에서 container_now 파일을 생성

```
root@c3c6d369d385:~# echo $(date) > container_now
root@c3c6d369d385:~# ls
container_now
root@c3c6d369d385:~# cat container_now
Fri Oct 2 07:07:44 UTC 2020
```

- container_now 파일 호스트로 복사

```
root@demo:~# docker container cp adoring_swirles:/root/container_now .
root@demo:~# ls
Dockerfile  container_now  main.go
root@demo:~# cat container_now
Fri Oct 2 07:07:44 UTC 2020
```



## 7. 컨테이너 단위 시스템 리소스 사용 확인

``docker container stats``

```
root@demo:~# docker container stats
CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDS
c3c6d369d385        adoring_swirles     0.01%               8.652MiB / 985MiB   0.88%               1.61kB / 0B         2.63MB / 8.19kB     12
CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDS
```





## 8. 컨테이너 표준 로그 출력

``docker container logs -f CONTAINER_NAME``

```assembly
[root@demo ~]# docker container logs -f nginx-latest
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Configuration complete; ready for start up
172.17.0.1 - - [11/Sep/2020:01:38:48 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.29.0" "-"
192.168.33.1 - - [11/Sep/2020:01:43:00 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36" "-"
2020/09/11 01:43:00 [error] 29#29: *2 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 192.168.33.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "192.168.33.10:8000", referrer: "http://192.168.33.10:8000/"
192.168.33.1 - - [11/Sep/2020:01:43:00 +0000] "GET /favicon.ico HTTP/1.1" 404 555 "http://192.168.33.10:8000/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36" "-"
```



# 컨테이너 데이터 영속적(persistent) 데이터로 활용

> 하는 이유

컨테이너는 이미지 파일만 있으면 생성/삭제 가능함

하지만, 컨테이너가 생성한 데이터는 보존해야할 경우가 있음

ex. 사용자들의 회원가입 db, 업로드 파일 등

==> 컨테이너의 생명주기와 관계없이 데이터 보존 할 수 있어야 한다.

=> 컨테이너가 죽거나 지워져도 호스트쪽에 데이터 남아있음

=> 재연결하면 볼륨과 다시 연결되어 호스트의 데이터가 컨테이너에 전달



## 방법1. 호스트 볼륨 공유

-v 옵션을 이용해서 호스트 볼륨을 공유

⇒ 호스트의 디렉터리를 컨테이너의 디렉터리에 마운트

⇒ 이미지에 원래 존재하는 디렉터리에 호스트의 볼륨을 공유하면 컨테이너의 디렉터리 자체가 덮어쓰게 됨



**#1 MYSQL 이미지를 이용한 DB 컨테이너 생성**

```
root@demo:~/blog# docker run -d --name wordpressdb_hostvolume \
> -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=wordpress \
> -v /root/wordpress_db:/var/lib/mysql mysql:5.7
```

- /root/wordpress_db 	⇒ 도커가 자동으로 생성
- /var/lib/mysql 	⇒ mysql 데이터베이스의 데이터를 저장하는 기본 디렉터리



**#2. wordpress 이미지를 이용한 웹서버 컨테이너 생성**

```
root@demo:~# docker run -d --name wordpress_hostvolume \
> -e WORDPRESS_DB_PASSWORD=password \
> --link wordpressdb_hostvolume:mysql \
> -p 80 wordpress
```

- --link wordpressdb_hostvolume:mysql  

  => wordpressdb_hostvolume을 컨테이너 내부에서 mysql이라고 명칭

**#3. 호스트 볼륨 공유 확인**

```
root@demo:~# ls /root/wordpress_db/
auto.cnf    client-cert.pem  ib_logfile0  ibtmp1              private_key.pem  server-key.pem
ca-key.pem  client-key.pem   ib_logfile1  mysql               public_key.pem   sys
ca.pem      ib_buffer_pool   ibdata1      performance_schema  server-cert.pem  wordpress
```

**#4. 컨테이너 내부 디렉터리 확인 => #3과 동일함**

```
root@demo:~# docker container exec wordpressdb_hostvolume ls /var/lib/mysql
auto.cnf    client-cert.pem  ib_logfile0  ibtmp1              private_key.pem  server-key.pem
ca-key.pem  client-key.pem   ib_logfile1  mysql               public_key.pem   sys
ca.pem      ib_buffer_pool   ibdata1      performance_schema  server-cert.pem  wordpress
```

**#5. wordpressdb_hostvolume 제거 후 호스트 볼륨 확인 => 남아있음**

```
root@demo:~# docker container rm -f wordpressdb_hostvolume
wordpressdb_hostvolume

root@demo:~# docker container ls
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                   NAMES
9c3e666bcc99        wordpress           "docker-entrypoint.s…"   12 minutes ago       Up 12 minutes       0.0.0.0:32768->80/tcp   wordpress_hostvolume
root@demo:~# ls /root/wordpress_db/
auto.cnf    client-cert.pem  ib_logfile0  ibtmp1              private_key.pem  server-key.pem
ca-key.pem  client-key.pem   ib_logfile1  mysql               public_key.pem   sys
ca.pem      ib_buffer_pool   ibdata1      performance_schema  server-cert.pem  wordpress
```

==> 컨테이너는 삭제되었지만 공유 파일은 그대로 호스트에 남아있음

==> 데이터이 영속성을 부여

**#6. MYSQL 이미지로 기존 호스트 볼륨 맵핑 => 호스트 볼륨 그대로 가져옴**

```
root@demo:~# docker run -d --name wordpressdb_hostvolume \
> -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=wordpress \
> -v /root/wordpress_db:/var/lib/mysql mysql:5.7
b045a109473cf5602a7c9c7545d124581955b6b92cc9b2a8bd31ff343075f007

root@demo:~# docker exec wordpressdb_hostvolume ls /var/lib/mysql
auto.cnf    client-cert.pem  ib_logfile0  ibtmp1              private_key.pem  server-key.pem
ca-key.pem  client-key.pem   ib_logfile1  mysql               public_key.pem   sys
ca.pem      ib_buffer_pool   ibdata1      performance_schema  server-cert.pem  wordpress
```



## 방법2. 볼륨 컨테이너 : 컨테이너 공유

-v 옵션으로 볼륨을 사용하는 컨테이너를 다른 컨테이너와 공유하는 것

컨테이너를 생성할 때 **--volumes-from 옵션**을 설정하면 

-v 또는 --volume 옵션을 적용한 컨테이너의 볼륨 디렉터리 공유가 가능



**#1 -v 옵션으로 볼륨을 사용하는 컨테이너를 확인**

```
vagrant@xenial64:~$ docker container ls
CONTAINER ID        IMAGE         COMMAND                  CREATED             STATUS              PORTS                   NAMES
39786eb6abac        wordpress     "docker-entrypoint.s…"  About an hour ago   Up About an hour    0.0.0.0:32778->80/tcp   wordpress_hostvolume
35eb27e65ad4        mysql:5.7     "docker-entrypoint.s…"  About an hour ago   Up About an hour    3306/tcp, 33060/tcp     wordpressdb_hostvolume

wordpressdb_hostvolume 없는 경우 아래 명령어로 컨테이너 생성
vagrant@xenial64:~/blog$ docker run -d --name wordpressdb_hostvolume -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=wordpress -v /home/vagrant/wordpress_db:/var/lib/mysql mysql:5.7
```

**#2 호스트 볼륨 공유를 확인**

```
vagrant@xenial64:~$ ls ~/wordpress_db/	⇐ 호스트의 디렉터리
auto.cnf    client-cert.pem  ibdata1      ibtmp1              private_key.pem  server-key.pem
ca-key.pem  client-key.pem   ib_logfile0  mysql               public_key.pem   sys
ca.pem      ib_buffer_pool   ib_logfile1  performance_schema  server-cert.pem  wordpress

vagrant@xenial64:~$ docker container exec -it wordpressdb_hostvolume ls /var/lib/mysql		⇐ 컨테이너 내부 
auto.cnf         client-key.pem  ibdata1             private_key.pem  sys
ca-key.pem       ib_buffer_pool  ibtmp1              public_key.pem   wordpress
ca.pem           ib_logfile0     mysql               server-cert.pem
client-cert.pem  ib_logfile1     performance_schema  server-key.pem

```

**#3 호스트와 볼륨을 공유하는 컨테이너를 공유하는 컨테이너를 생성**

```
vagrant@xenial64:~$ docker run -it --name volume_from_container --volumes-from wordpressdb_hostvolume ubuntu:14.04
root@d6ec70aa8c04:/# ls /var/lib/mysql
auto.cnf    client-cert.pem  ib_logfile0  ibtmp1              private_key.pem  server-key.pem
ca-key.pem  client-key.pem   ib_logfile1  mysql               public_key.pem   sys
ca.pem      ib_buffer_pool   ibdata1      performance_schema  server-cert.pem  wordpress
```

- --volumes-from wordpressdb_hostvolume 

  => wordpressdb_hostvolume 의 -v 옵션 볼륨 공유하겠다 





## 방법3. 도커 볼륨

도커 자체가 제공하는 볼륨 기능을 활용

docker volume 명령어를 사용



**#1 볼륨 생성**

호스트의 myvolume은 그냥 공간만 주는것! 

```
vagrant@xenial64:~$ docker volume create --name myvolume
myvolume

vagrant@xenial64:~$ docker volume ls
DRIVER              VOLUME NAME
local               myvolume
```

**#2 생성한 볼륨을 이용해서 컨테이너를 생성**

-v  공유볼륨이름:컨테이너내부디렉터리

```
vagrant@xenial64:~$ docker run -it --name myvolume1 -v myvolume:/root/ ubuntu:14.04
root@f180dcf1df5f:/# ls
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr
root@f180dcf1df5f:/# cd root
root@f180dcf1df5f:~# ls
root@f180dcf1df5f:~# echo hello,volume
hello,volume
root@f180dcf1df5f:~# echo hello,volume >> /root/volume
root@f180dcf1df5f:~# ls
volume
root@f180dcf1df5f:~# exit
exit
```

**#3 동일 볼륨을 사용하는 컨테이너를 생성해서 공유 여부를 확인**

```
vagrant@xenial64:~$ docker run -it --name myvolume2 -v myvolume:/temp/ ubuntu:14.04
root@91f72e240487:/# cd /temp/
root@91f72e240487:/temp# ls
volume
root@91f72e240487:/temp# cat volume
hello,volume
```

**#4 docker inspect 명령으로 볼륨의 저장 위치를 확인**

```
vagrant@xenial64:~$ docker inspect --type volume myvolume
[
    {
        "CreatedAt": "2020-09-16T00:42:43Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/myvolume/_data",
        "Name": "myvolume",
        "Options": {},
        "Scope": "local"
    }
]
```

==> /var/lib/docker/volumes/myvolume/_data 경로의 파일이 공유됨



------

**동일한 컨테이너 이름을 사용할 수 없음**

```
vagrant@xenial64:~$ docker container run --name echo -itd -p 8888:8080 myanjini/echo:latest /bin/bash

# 동일 이름 컨테이너로 실행 => 같은이름있다고 에러뜸
vagrant@xenial64:~$ docker container run --name echo -itd -p 8889:8080 myanjini/echo:latest /bin/bash
docker: Error response from daemon: Conflict. The container name "/echo" is already in use by container "32b348b10a6244a6f8704bbb67a9450d2ebe7d6e8e40243623bade035edf0acb". You have to remove (or rename) that container to be able to reuse that name.
See 'docker run --help'.

# 기존 같은 이름 컨테이너 제거
vagrant@xenial64:~$ docker container rm -f echo

# 재실행
vagrant@xenial64:~$ docker container run --name echo -itd -p 8889:8080 myanjini/echo:latest /bin/bash
3148d692d80fb153e48ba95eb3fd5c5b9a5559c3f8bf01242eac9abf69326997

```

**기존에 생성된 컨테이너가 있으면 삭제하고, 새롭게 컨테이너를 생성**

```
# 기존에 같은이름 컨테이너 있으면 제거하고 새롭게 생성
vagrant@xenial64:~$ docker container rm -f echo ; docker container run --name echo -itd -p 8889:8080 myanjini/echo:latest /bin/bash
echo
1f6d2aa0a93f07355b73131431d19cdfdff7ef4cb86818393fa5b9a4a9bd75b9
```



> QUIZ : 동일 이름 컨테이너 있으면 제거하고 재실행하는 쉘 스크립트
>
> ```
> #!/bin/bash
> 
> if [ $# == 0 ]
> then
>     echo 명령어 형식이 잘못되었습니다.
>     echo [사용법] ./run.sh container_name
>     exit 1
> fi
> 
> # echo "모든 컨테이너 목록"
> # docker container ps -a
> 
> cid=$(docker container ps -a --filter "name=$1" -q)
> 
> # if cid not null
> if [-n cid ]
> then
>     docker container rm -f $cid
>     echo $1 이름의 컨테이너 \($cid\) 를 삭제했습니다.
> 
> exit 0
> ```





# Dockerfile

: 이미지 생성을 위해 만드는 파일

이미지 생성 : ``docker image build IMAGE_NAME DOCKERFILE_PATH``



## Dockerfile로 이미지 빌드 시 주의사항

Dockerfile의 명령어 줄 수 만큼의 레이어가 존재

==> 공간만 차지함  ==> **RUN 명령어는 하나로 묶어서 실행**

```
FROM ubuntu

RUN  mkdir /test

RUN  fallocate  -l  100m  /test/dumy

RUN  rm  /test/dumy
```

```
FROM ubuntu

RUN  mkdir /test  &&  fallocate  -l  100m  /test/dumy  &&  rm  /test/dumy
```







## Dockerfile 예시

### CentosOS Dockerfile

https://hub.docker.com/_/centos 참고

https://github.com/CentOS/sig-cloud-instance-images/blob/f2788ce41161326a18420913b0195d1c6cfa1581/docker/Dockerfile centos7버전

```
FROM scratch   ----------> 베이스 이미지(기본이 되는 이미지) 지정
ADD centos-7-x86_64-docker.tar.xz /    ----------> 이미지 파일을 추가

LABEL \
    org.label-schema.schema-version="1.0" \
    org.label-schema.name="CentOS Base Image" \
    org.label-schema.vendor="CentOS" \
    org.label-schema.license="GPLv2" \
    org.label-schema.build-date="20200809" \
    org.opencontainers.image.title="CentOS Base Image" \
    org.opencontainers.image.vendor="CentOS" \
    org.opencontainers.image.licenses="GPL-2.0-only" \
    org.opencontainers.image.created="2020-08-09 00:00:00+01:00"

CMD ["/bin/bash"] -------> 컨테이너 기동 시, 실행할 default 프로세스를 지정
```

* 베이스 이미지 : 이미지 파일 만들때 참고가되는 이미지 파일을 기반으로 만든다

  FROM scratch     아무 기반되는 파일 없이 만든다...

  FROM debian:buster-slim      debian:buster-slim  기반으로 만든다

- 이미지 파일을 추가

  ADD : 압축파일을 풀어서 배치 , COPY : 단순복사



### Nginx Dockerfile

https://hub.docker.com/_/nginx 참고

https://github.com/nginxinc/docker-nginx/blob/9774b522d4661effea57a1fbf64c883e699ac3ec/mainline/buster/Dockerfile nginx latest 버전

```
FROM debian:buster-slim			---------> 베이스 이미지를 지정
	:
COPY docker-entrypoint.sh /    ----------> 호스트 파일을 컨테이너 이미지 내부로 복사
COPY 10-listen-on-ipv6-by-default.sh /docker-entrypoint.d
COPY 20-envsubst-on-templates.sh /docker-entrypoint.d
ENTRYPOINT ["/docker-entrypoint.sh"]  ---> docker 실행시 자동 실행해줄 파일

EXPOSE 80              ----------> 80포트를 사용한다는 것을 외부에 알려줌

STOPSIGNAL SIGTERM

CMD ["nginx", "-g", "daemon off;"]

```

- COPY docker-entrypoint.sh / 

  : 이미지를 생성할 호스트 파일을 컨테이너 이미지 내부로 복사

- ENTRYPOINT ["/docker-entrypoint.sh"]

  :docker run 명령으로 컨테이너를 생성하거나, 

  docker start 명령으로 정지된 컨테이너를 시작할 때 해당 파일 실행해주기

  쉘파일없이 실행해주기

  **ENTRYPOINT는 Dockerfile에서 단 한번만 사용 가능**

- EXPOSE 80

  : 호스트와 연결할 포트 번호를 설정



## Dockerfile 만들기

### 실습1. 쉘 파일 생성 후 dockerfile 만들기

```
root@demo:~# cat helloworld
#!/bin/sh

echo "Hello, World!"
root@demo:~# ls -l
total 4
-rwxr-xr-x 1 root root 32 Oct  2 04:43 helloworld
```

```
root@demo:~# cat Dockerfile

#베이스 이미지 정의
FROM ubuntu:16.04
#호스트의 helloworld 파일을 컨테이너 안의 /usr/local/bin 경로로 복사
COPY helloworld /usr/local/bin
# 도커 빌드 과정에서 컨테이너 안에서 실행할 명령
RUN chmod +x /usr/local/bin/helloworld
# 도커 컨테이너로 실행하기 전에 실행할 명령
CMD [ "helloworld" ]
```

- 이미지 빌드 명령어

```
root@demo:~# docker image build -t helloworld:latest .
```

​	-> docker image build : 이미지 빌드 명령어

​	-> -t helloworld:latest : 이미지 이름을 명시

​	-> **.**  : 도커파일 위치(현재 디렉터리)



- 만들어진 이미지로 컨테이너 실행 및 조회

```
root@demo:~# docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
helloworld          latest              f223e41b24cc        4 minutes ago       127MB
ubuntu              16.04               096efd74bb89        6 days ago          127MB


root@demo:~# docker run  -it  --name hello helloworld
Hello, World!

root@demo:~# docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
f3f24b16a005        helloworld          "helloworld"        8 seconds ago       Exited (0) 6 seconds ago                       hello
```



### 실습2. 8080포트 요청 시 Hello, Docker 출력

- go 파일 생성

```
root@demo:~# cat main.go
package main

import (
        "fmt"
        "log"
        "net/http"
)

func main() {
        http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
                log.Println("received request")
                fmt.Fprintf(w, "Hello Docker!!")
        })
        log.Println("start server")
        server := &http.Server{ Addr: ":8080" }
        if err := server.ListenAndServe(); err != nil {
                log.Println(err)
        }
}
```

- Dockerfile 생성

```
root@demo:~# cat Dockerfile
FROM golang:1.9
RUN mkdir /echo
COPY main.go /echo
CMD [ "go", "run", "/echo/main.go" ]
```

- 이미지 생성

```
root@demo:~# docker image build -t example/echo:latest .
```

- 컨테이너 실행

```
root@demo:~# docker container run -d example/echo:latest
c3c6d369d385ef649aa97ced7e0554c09eceedb7eb8efc6a73a47c439c5078cb
```





# 이미지 파일 만들기

## 방법 1. Dockerfile을 이용해서 이미지를 생성

**#1 컨테이너 이미지 내부로 전달할 파일을 생성**

```
[root@demo ~]# echo "Hello, Dockekr." > hello-docker.txt
```

**#2 Dockerfile을 생성 -> 이미지 생성에 사용**

```assembly
[root@demo ~]# vi Dockerfile
FROM docker.io/centos:latest   -------> 베이스 이미지 지정
ADD hello-docker.txt /tmp      
-------> 호스트에 있는 hello-docker.txt 파일을 컨테이너 이미지의 /tmp 아래로 복사
RUN yum install -y epel-release ------> 컨테이너 이미지를 만들 때 실행
CMD [ "/bin/bash" ]             ------> 컨테이너 실행 시 실행할 명령어
```

**#3 Dockerfile을 이용해서 이미지를 생성** (이미지를 만드는 첫번째 방법)

```
[root@demo ~]# docker image build -t ok2qw66/centos:1.0 .
Sending build context to Docker daemon 20.39 MB
Step 1/4 : FROM docker.io/centos:latest
 ---> 0d120b6ccaa8
Step 2/4 : ADD hello-docker.txt /tmp
 ---> 7db1f5b4acfb
Removing intermediate container 5540cae51198
Step 3/4 : RUN yum install -y epel-release
 ---> Running in ccd4a257d0be
 :
 Successfully built 6d7c8ba30de8    -------> 이미지 ID
 
 [root@demo ~]# docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ok2qw66/centos      1.0                 6d7c8ba30de8        8 seconds ago       215 MB
docker.io/nginx     latest              7e4d58f0e5f3        14 hours ago        133 MB
docker.io/ubuntu    latest              4e2eef94cd6b        3 weeks ago         73.9 MB
docker.io/centos    centos7             7e6257c9f8d8        4 weeks ago         203 MB
docker.io/centos    latest              0d120b6ccaa8        4 weeks ago         215 MB
```

**#4 생성한 이미지를 이용해서 컨테이너를 실행**

```
[root@demo ~]# docker container run -td --name devops-book-1.0 ok2qw66/centos:1.0
82ed691c6188b35f21f31b3520e1cd1cf12b1eb05bbe70104cf4513423585251
-----------------> container ID

[root@demo ~]# docker container ls
CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS              PORTS                  NAMES
82ed691c6188        ok2qw66/centos:1.0   "/bin/bash"              5 seconds ago       Up 4 seconds                               devops-book-1.0
38b130102fed        nginx                "/docker-entrypoin..."   About an hour ago   Up About an hour    0.0.0.0:8000->80/tcp   nginx-latest
d0450c56e21c        docker.io/ubuntu     "/bin/bash"              About an hour ago   Up About an hour                           ubuntu
```

**#5 컨테이너 내부로 진입**

```
[root@demo ~]# docker exec -it devops-book-1.0 /bin/bash
# 이미지 생성 중 파일 복사되었는지 확인
[root@aa9eab5ad4c1 /]# cat /tmp/hello-docker.txt		
Hello, Docker.
# epel 패키지 설치 여부를 확인
[root@aa9eab5ad4c1 /]# rpm -qa | grep epel			
epel-release-8-8.el8.noarch
```

## 방법2. 컨테이너 내용을 변경 후 변경된 내용을 이미지로 생성

> yum install 설치가 안될경우???
>
> 1. 방화벽 실행되어 있는지 확인하기
>
>    HOST(Vagrant로 설치한 CentOS)에서 systemctl start firewalld 명령으로 방화벽을 실행 후 컨테이너 내부에서 다시 yum install 

```
# Dockerfile에서 epel 패키지 설치하지 않은 경우
[root@aa9eab5ad4c1 /]# yum install -y epel-release
# 컨테이너 내부에 nginx를 설치
[root@aa9eab5ad4c1 /]# yum install -y nginx
[root@aa9eab5ad4c1 /]# exit
```

docker container commit : container의 현재 상태를 이미지로 기록(생성)

devops-book-1.0 : 컨테이너 이름

ok2qw66/centos:1.1 : 새로 만들 이미지 파일

**commit으로 현재 컨테이너(devops-book-1.0)를 이미지로 생성**

```
[root@demo ~]# docker container commit devops-book-1.0 ok2qw66/centos:1.1
sha256:7490013a568a6f4710a02aa3adf610fb7daedd8543a42751568380181590744c
---------------------> container id

[root@demo ~]# docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ok2qw66/centos      1.1                 7490013a568a        7 seconds ago       310 MB
ok2qw66/centos      1.0                 6d7c8ba30de8        15 minutes ago      215 MB
docker.io/nginx     latest              7e4d58f0e5f3        14 hours ago        133 MB
docker.io/ubuntu    latest              4e2eef94cd6b        3 weeks ago         73.9 MB
docker.io/centos    centos7             7e6257c9f8d8        4 weeks ago         203 MB
docker.io/centos    latest              0d120b6ccaa8        4 weeks ago         215 MB
```



## 도커 허브에 이미지를 등록

> denied: requested access to the resource is denied 오류가 발생하는 경우???
>
> 1. docker login 하지 않은 경우 
>
> 2. 도커 이미지의 사용자 명이 도커 허브와 다른 경우, docker tag 명령으로 이름을 변경한 후 등록하기
>
>    ```
>    [root@demo ~]# docker tag 원본이미지명 변경이미지명 
>    ```

```
[root@demo ~]# docker image push ok2qw66/centos:1.1
The push refers to a repository [docker.io/ok2qw66/centos]
c7b3bba4f341: Pushed
bb9590f5aebf: Pushed
291f6e44771a: Mounted from library/centos
1.1: digest: sha256:2910bd941f92412afe553df5a642c70aa3781edf1b4797b73f5cce25c451c8ce size: 948
```

- 도커 허브에 로그인 후 등록된 이미지를 확인

![image-20200911133941827](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20200911133941827.png)

- 도커 허브에 등록된 이미지를 이용해서 컨테이너를 실행

```
[root@demo ~]# docker run --name ok2qw66_centos -dt -p 8888:80 ok2qw66/centos:1.1
35863b64d8b49f75059e683cc711ad3fa10d762a752bc32d8f93979ce883bd37


[root@demo ~]# docker container ls
CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS              PORTS                  NAMES
35863b64d8b4        ok2qw66/centos:1.1   "/bin/bash"              7 seconds ago       Up 6 seconds        0.0.0.0:8888->80/tcp   ok2qw66_centos
82ed691c6188        ok2qw66/centos:1.0   "/bin/bash"              About an hour ago   Up About an hour                           devops-book-1.0
38b130102fed        nginx                "/docker-entrypoin..."   2 hours ago         Up 2 hours          0.0.0.0:8000->80/tcp   nginx-latest
d0450c56e21c        docker.io/ubuntu     "/bin/bash"              3 hours ago         Up 3 hours                                 ubuntu


[root@demo ~]# docker exec -it ok2qw66_centos
```























# Docker Compose

> **Docker compose 사용하는 이유??**
>
> 도커파일 =  하나의 컨테이너를 만들기 위한 파일
>
> 여러개의 컨테이너를 묶어서 동작하게 하고싶다 ===> 도커 컴포즈 사용하기



## Docker Composer 설치

https://docs.docker.com/compose/install/

```
root@demo:/usr/bin# sudo curl -L "https://github.com/docker/compose/releases/download/1.27.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   651  100   651    0     0   1788      0 --:--:-- --:--:-- --:--:--  1788
100 11.6M  100 11.6M    0     0  2116k      0  0:00:05  0:00:05 --:--:-- 2474k

root@demo:/usr/bin# chmod +x /usr/local/bin/docker-compose

root@demo:/usr/bin# docker-compose version
docker-compose version 1.27.2, build 18f557f9
docker-py version: 4.3.1
CPython version: 3.7.7
OpenSSL version: OpenSSL 1.1.0l  10 Sep 2019
```

| 설명                                                 | 명령어                                   |
| ---------------------------------------------------- | ---------------------------------------- |
| docker-compose 실행                                  | docker-compose up -d                     |
| Dockerfile로 이미지 빌드 후<br />docker-compose 실행 | docker-compose up -d --built             |
| docker-compose 리스트 확인                           | docker-compose ps                        |
| 컨테이너 수 증설/축소                                | docker-compose scale CONTAINER_NAME:갯수 |
| docker-compose 중지                                  | docker-compose down                      |



### docker-compose 명령으로 컨테이너를 실행

#### #1. docker-compose.yml 파일을 생성 

https://docs.docker.com/compose/compose-file/

(컨테이너 3개 :db/app/web 만들기)

```
[root@demo ~]# vi docker-compose.yml
db:
  image: docker.io/mysql       ⇒ 컨테이너 이미지
  ports:
    - "3306:3306"              ⇒ 호스트 포트 : 컨테이너 내부 포트(서비스 포트)
  environment:                 ⇒ 컨테이너 내부의 환경 변수
    - MYSQL_ROOT_PASSWORD=password

app:
  image: docker.io/tomcat
  ports:
    - "9090:8080"

web:
  image: docker.io/nginx
  ports:
    - "9000:80"

```

#### #2. 컨테이너 생성 및 확인

```
[root@demo ~]# docker-compose up -d
:
Creating root_web_1
Creating root_db_1
Creating root_app_1
```

```
[root@demo ~]# docker container ls
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES
1c2be0ca2497        docker.io/tomcat    "catalina.sh run"        19 seconds ago      Up 18 seconds       0.0.0.0:9090->8080/tcp              root_app_1
05fa3572479b        docker.io/nginx     "/docker-entrypoin..."   19 seconds ago      Up 18 seconds       0.0.0.0:9000->80/tcp                root_web_1
c150055aa861        docker.io/mysql     "docker-entrypoint..."   19 seconds ago      Up 18 seconds       0.0.0.0:3306->3306/tcp, 33060/tcp   root_db_1
```

#### #3. 컨테이너를 중지

```
[root@demo ~]# docker-compose down
Stopping root_app_1 ... done
Stopping root_web_1 ... done
Stopping root_db_1 ... done
Removing root_app_1 ... done
Removing root_web_1 ... done
Removing root_db_1 ... done
```

**스냅샷 생성**

```
C:\HashiCorp\WorkDir>vagrant snapshot save V3
==> default: Snapshotting the machine as 'V3'...
==> default: Snapshot saved! You can restore the snapshot at any time by
==> default: using `vagrant snapshot restore`. You can delete it using
==> default: `vagrant snapshot delete`.

C:\HashiCorp\WorkDir>vagrant snapshot list
==> default:
V2
V3
```



### 이미지를 만들고 컨테이너를 실행

#### #1. docker-compose.yml 파일 생성

```
root@demo:~# mkdir compose && cd ~/compose

root@demo:~/compose# ls
Dockerfile  docker-compose.yml  main.go

root@demo:~/compose# cat Dockerfile
FROM   golang:1.9
RUN    mkdir   /echo
COPY   main.go   /echo
CMD   [ "go", "run", "/echo/main.go" ]


root@demo:~/compose# cat main.go
package main

import (
        "fmt"
        "log"
        "net/http"
)

func main() {
        http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
                log.Println("received request")
                fmt.Fprintf(w, "Hello Docker!!")
        })
        log.Println("start server")
        server := &http.Server{ Addr: ":8080" }
        if err := server.ListenAndServe(); err != nil {
                log.Println(err)
        }
}


root@demo:~/compose# cat docker-compose.yml
version: "3"						-> 문법 버전
services:							
  echo:								-> 컨테이너 이름
    #image: myanjini/echo:latest	-> 컨테이너 생성 이미지
    build: .						-> Dockerfile 위치
    -> Dockerfile 이용해서 이미지 빌드 후 실행
    ports:
      - 9000:8080					-> 포트포워딩 host:container				
```

#### #2. 컨테이너 실행(이미지 빌드 후 실행) 및 확인

``docker-compose up -d --build``

```
root@demo:~/compose# docker-compose up -d --build
```

```
root@demo:~/compose# docker image ls
REPOSITORY      TAG     IMAGE ID         CREATED         SIZE
compose_echo    latest  c476c9229486     13 seconds ago  750MB
```

```
root@demo:~/compose# docker container ls
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
bd27dfd4c27b        compose_echo        "go run /echo/main.go"   2 minutes ago       Up 2 minutes        0.0.0.0:9000->8080/tcp   compose_echo_1
```

```
root@demo:~/compose# curl http://localhost:9000
Hello Docker!!
```

#### #3. 컨테이너 중지

```
root@demo:~/compose# docker-compose down
Stopping compose_echo_1 ... done
Removing compose_echo_1 ... done
Removing network compose_default
```



### MYSQL과 Wordpress 연동

#### #1. docker-compose.yml 생성

```
root@demo:~# root@demo:~# cat docker-compose.yml
version: "3.3"
services:
  db:
    image: library/mysql:5.7
    volumes:
      - /root/db_data:/var/lib/mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress

  wordpress:
    depends_on:
     - db								-> 위에적힌 서비스이름
    image: library/wordpress:latest
    ports:
      - "80:80"
    restart: always
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
volumes:
  db_data: {}
```

#### #2. 컨테이너 생성 및 확인

- 컨테이너 생성 : ``docker-compose up -d``
- 컨테이너 목록 : ``docker-compose ps``

```
root@demo:~# docker-compose up -d
		:
Creating root_db_1 ... done
Creating root_wordpress_1 ... done
```

```
root@demo:~# docker-compose ps
      Name                    Command               State          Ports
-------------------------------------------------------------------------------
root_db_1          docker-entrypoint.sh mysqld      Up      3306/tcp, 33060/tcp
root_wordpress_1   docker-entrypoint.sh apach ...   Up      0.0.0.0:80->80/tcp
root@demo:~#
```

#### #3. virtualbox에서 포트포워딩 및 접속 확인

![image-20201003170908312](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201003170908312.png)

- PC에서 http://localhost:8888 접속 시

![image-20201003171102663](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201003171102663.png)



> **부가설명**

![image-20200916144443863](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20200916144443863.png)

PC: 윈도우 PC			Browser : 윈도우 pc에서 띄우는 웹브라우저
V: virtual Box			 U : ubuntu 가상머신
W: wordpress			M: Mysql

**1 : ** 웹브라우저에서 8888포트로 접속하면 U의 80포트로 연결됨

==> 포트 포워딩 적용필요

![image-20200916144732460](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20200916144732460.png)



**2 : **U의 80포트로 접속하면  W의 80포트로 연결

==> dokcer-compose.yml 파일에서 ports 부분

![image-20200916144913022](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20200916144913022.png)



## Docker Compose 사용하는 이유

- 여러개의 컨테이너를 조합해서 생성/중지 가능

- 동일 컨테이너를 증설하고 축소하는게 쉽다



### docker-compose scale : 컨테이너 증설/축소

#### #1. docker-compose.yml 수정(호스트포트 고정X)

```
vagrant@xenial64:~/compose$ cat docker-compose.yml
version: "3.3"

services:
  db:
    image: library/mysql:5.7
    volumes:
      - /home/vagrant/db_data:/var/lib/mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress

  wordpress:
    depends_on:
      - db
    image: library/wordpress:latest
    ports:
      - "80"        ======> 받는 wordpress 포트는 80으로 고정하되, 가상서버포트는 미지정
    restart: always
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
volumes:
  db_data: {}
```



#### #2. 컨테이너 갯수 scale 조정

컨테이너 실행 시 갯수 조정: ``docker-compose up -d --scale CONTAINER_NAME:갯수``

실행 중인 컨테이너 수 조정 : ``docker-compose scale CONTAINER_NAME:갯수``

```
# db컨테이너 2개로 설정후 실행
vagrant@xenial64::~/compose$ docker-compose up -d --scale db=2
Creating network "root_default" with the default driver
Creating root_db_1 ... done
Creating root_db_2 ... done
Creating root_wordpress_1 ... done

# db컨테이너 2개생성 확인
vagrant@xenial64:~/compose$ docker-compose ps
      Name                    Command               State          Ports
-------------------------------------------------------------------------------
root_db_1          docker-entrypoint.sh mysqld      Up      3306/tcp, 33060/tcp
root_db_2          docker-entrypoint.sh mysqld      Up      3306/tcp, 33060/tcp
root_wordpress_1   docker-entrypoint.sh apach ...   Up      0.0.0.0:32769->80/tcp


# db 2개 wordpress 2개로 컨테이너 생성
vagrant@xenial64:~/compose$ docker-compose scale db=2 wordpress=2
WARNING: The scale command is deprecated. Use the up command with the --scale flag instead.
Creating compose_db_1 ... done
Creating compose_db_2 ... done
Creating compose_wordpress_1 ... done
Creating compose_wordpress_2 ... done


============= 서버 증설하고 싶을때 ================

# db 4개 wordpress 5개로 컨테이너 수 조절
vagrant@xenial64:~/compose$ docker-compose scale db=4 wordpress=5
WARNING: The scale command is deprecated. Use the up command with the --scale flag instead.
Starting compose_db_1 ... done
Starting compose_db_2 ... done
Creating compose_db_3 ... done
Creating compose_db_4 ... done
Starting compose_wordpress_1 ... done
Starting compose_wordpress_2 ... done
Creating compose_wordpress_3 ... done
Creating compose_wordpress_4 ... done
Creating compose_wordpress_5 ... done

# 현재 db 4개 wordpress 5개 뜬 상태
vagrant@xenial64:~/compose$ docker-compose ps
       Name                      Command                 State              Ports
-----------------------------------------------------------------------------------------
compose_db_1          docker-entrypoint.sh mysqld      Up           3306/tcp, 33060/tcp
compose_db_2          docker-entrypoint.sh mysqld      Up           3306/tcp, 33060/tcp
compose_db_3          docker-entrypoint.sh mysqld      Restarting
compose_db_4          docker-entrypoint.sh mysqld      Up           3306/tcp, 33060/tcp
compose_wordpress_1   docker-entrypoint.sh apach ...   Up           0.0.0.0:32769->80/tcp
compose_wordpress_2   docker-entrypoint.sh apach ...   Up           0.0.0.0:32770->80/tcp
compose_wordpress_3   docker-entrypoint.sh apach ...   Up           0.0.0.0:32773->80/tcp
compose_wordpress_4   docker-entrypoint.sh apach ...   Up           0.0.0.0:32771->80/tcp
compose_wordpress_5   docker-entrypoint.sh apach ...   Up           0.0.0.0:32772->80/tcp


============= 서버 줄이고 싶을때 ================

# db 1개 wordpress 1개로 조정
vagrant@xenial64:~/compose$ docker-compose scale db=1 wordpress=1
WARNING: The scale command is deprecated. Use the up command with the --scale flag instead.
Stopping and removing compose_db_2 ... done
Stopping and removing compose_db_3 ... done
Stopping and removing compose_db_4 ... done
Stopping and removing compose_wordpress_2 ... done
Stopping and removing compose_wordpress_3 ... done
Stopping and removing compose_wordpress_4 ... done
Stopping and removing compose_wordpress_5 ... done

# db 1개, wordpress 1개 뜬 상태 확인
vagrant@xenial64:~/compose$ docker-compose ps
       Name                      Command               State           Ports
------------------------------------------------------------------------------------
compose_db_1          docker-entrypoint.sh mysqld      Up      3306/tcp, 33060/tcp
compose_wordpress_1   docker-entrypoint.sh apach ...   Up      0.0.0.0:32769->80/tcp
vagrant@xenial64:~/compose$

```







# **devops의 키워드 : 자동화 

자동화 ==> 사람이 처음과 끝에 간섭하지 않아야 한다

![image-20201001164553597](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201001164553597.png)



------





# Jenkins 

### #1 JDK 설치

```
[root@demo ~]# yum -y install java-1.8.0-openjdk java-1.8.0-openjdk-devel
```



### #2 Jenkins 설치

공식 설치 문서(CentOS 환경) ⇒ https://pkg.jenkins.io/redhat-stable/

```
[root@demo ~]# yum -y install http://mirrors.jenkins-ci.org/redhat-stable/jenkins-2.235.5-1.1.noarch.rpm
```



### #3 Jenkins 기동

호스트 PC에서 브라우저를 이용해서 **http://IP:8080/** 로 접속

접속에 필요한 password를 확인(/var/lib/jenkins/secrets/initialAdminPassword) 후 접속한다.

```
# host 마다 다 다르다
[root@demo ~]# cat /var/lib/jenkins/secrets/initialAdminPassword
061a80505fc54984bf10dce7a7564e47
```



![image-20200911145041547](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20200911145041547.png)



>
>
>**접속되지 않는 경우 방화벽에 서비스 포트를 등록(허용)**
>
>```
>[root@demo ~]# systemctl start firewalld
># 8080포트 접속가능하게 설정
>[root@demo ~]# firewall-cmd --zone=public --permanent --add-port=8080/tcp
># 방화벽 재기동
>[root@demo ~]# firewall-cmd --reload
>```
>
>



### #4 Jenkins 최초 설정

\#4-1 Install suggested plugins 클릭

#4-2 설치를 진행

#4-3 관리자 계정 설정   :   admin  / password

#4-4 재시작



### #5 프로젝트 생성

![image-20200911150826152](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20200911150826152.png)

![image-20200911151307519](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20200911151307519.png)

**#7 프로젝트 실행 (build now)**

![image-20200911151938503](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20200911151938503.png)

**#9 프로젝트 결과 일람**

![image-20200911152007375](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20200911152007375.png)

- 1분 단위로 실행

![image-20201001165801715](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201001165801715.png)



## Jenkins에서 Ansible 실행

(이전에 사용하였던 ansible-playbook-sample 사용)

출처 : https://myanjini.tistory.com/entry/Jenkins-Ansible-Serverspec-%EC%97%B0%EB%8F%99-1

### #1 jenkins 사용자가 패스워드 없이 sudo 명령어를 실행할 수 있도록

sudoer 파일에 규칙 추가

```
[vagrant@demo ~]$ sudo vi /etc/sudoers.d/jenkins
jenkins ALL=(ALL) NOPASSWD:ALL
```



### #2 exec-ansible 프로젝트 생성하여 Build> Execute shell 내용 입력

![image-20201001170549298](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201001170549298.png)

```
cd /home/vagrant/ansible-playbook-sample
ansible-playbook -i development site.yml --diff
```



### #3 exec-serverspec 프로젝트 생성하여 Build> Execute shell 내용 입력

![image-20201001170636264](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201001170636264.png)

```
cd /home/vagrant/serverspec_sample
/usr/local/rvm/rubies/ruby-2.7.0/bin/rake spec
```



## Pipeline으로 프로젝트 연결

### #1 새로운 프로젝트 > pipeline으로 item 생성

![image-20201001171112199](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201001171112199.png)

### #2 pipeline script 창에 내용 입력

![image-20201001171227245](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201001171227245.png)

```go
node{
    stage 'ansible'
    build 'exec-ansible'
    stage 'serverspec'
    build 'exec-serverspec'
}
```



## parameter 입력받기

- exec-ansible 프로젝트 수정

  ​    -   exec-ansible에서 General부분에 매개변수 추가

![image-20201001171305628](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201001171305628.png)

​				- Command 부분 수정

![image-20201001171400506](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201001171400506.png)

```
cd /home/vagrant/ansible-playbook-sample
ansible-playbook -i $(ENVIRONMENT) site.yml --diff
```



- exec-serverspec 프로젝트 수정

  ![image-20201001171652737](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201001171652737.png)

![image-20201001171718895](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20201001171718895.png)

```
node{
    stage 'ansible'
    build job: 'exec-ansible', parameters: [[$class: 'StringParameterValue', name: 'ENVIRONMENT', value: "${ENVIRONMENT}"]]
    stage 'serverspec'
    build 'exec-serverspec'
}
```





> ### 왜 production 으로 pipeline 돌리면 에러가 뜰까요?

```
Failures:

  1) File "/usr/share/nginx/html/index.html" content is expected to match /^Hello, development ansible!!$/
     On host `localhost'
     Failure/Error: its(:content) { should match /^Hello, development ansible!!$/ }
       expected "Hello, production ansible!!\n" to match /^Hello, development ansible!!$/
       Diff:
       @@ -1 +1 @@
       -/^Hello, development ansible!!$/
       +Hello, production ansible!!
       /bin/sh -c cat\ /usr/share/nginx/html/index.html\ 2\>\ /dev/null\ \|\|\ echo\ -n
       Hello, production ansible!!

     # ./spec/localhost/web_spec.rb:19:in `block (2 levels) in <top (required)>'

Finished in 0.27267 seconds (files took 1.35 seconds to load)
7 examples, 1 failure

Failed examples:

rspec ./spec/localhost/web_spec.rb:19 # File "/usr/share/nginx/html/index.html" content is expected to match /^Hello, development ansible!!$/

/usr/local/rvm/rubies/ruby-2.7.0/bin/ruby -I/usr/local/rvm/rubies/ruby-2.7.0/lib/ruby/gems/2.7.0/gems/rspec-support-3.9.3/lib:/usr/local/rvm/rubies/ruby-2.7.0/lib/ruby/gems/2.7.0/gems/rspec-core-3.9.2/lib /usr/local/rvm/rubies/ruby-2.7.0/lib/ruby/gems/2.7.0/gems/rspec-core-3.9.2/exe/rspec --pattern spec/localhost/\*_spec.rb failed
Build step 'Execute shell' marked build as failure
Finished: FAILURE
```



1. serverspec_sample 테스트 시 사용되는 파일 보기

```
[vagrant@demo ~]$ cat /tmp/serverspec_sample/spec/localhost/web_spec.rb
require 'spec_helper'

describe package('nginx') do
  it { should be_installed }
end

describe service('nginx') do
  it { should be_enabled }
  it { should be_running }
end

describe port(80) do
  it { should be_listening }
end

describe file('/usr/share/nginx/html/index.html') do
  it { should be_file }
  it { should exist }
  its(:content) { should match /^Hello, development ansible!!$/ } 
  ------------------------------------> development로 되어있음
end
```



2. test 케이스 만들때 사용하는 템플릿을 보기

```
[vagrant@demo ~]$ cat /tmp/ansible-playbook-sample/roles/serverspec_sample/templates/web_spec.rb.j2
require 'spec_helper'

describe package('nginx') do
  it { should be_installed }
end

describe service('nginx') do
  it { should be_enabled }
  it { should be_running }
end

describe port(80) do
  it { should be_listening }
end

describe file('/usr/share/nginx/html/index.html') do
  it { should be_file }
  it { should exist }
  its(:content) { should match /^Hello, {{ env }} ansible!!$/ }
end
```

{{env}} 로 잘 되어있는데... 왜 동작을 안하지??



3. ansible 롤을 정의하고 있는 site.yml 파일을 확인

```
[vagrant@demo ~]$ cat /tmp/ansible-playbook-sample/site.yml
---
- hosts: webservers
  become: yes
  connection: local
  roles:
    - common
    - nginx
#    - serverspec         ⇐ serverspec 설치
#    - serverspec_sample  ⇐ serverspec 에서 사용할 테스트 케이스를 만들어서 /tmp/serverspec_sample 디렉터리로 복사=======> 주석해제해줘야 test 적용/사용가능!!
#    - jenkins	
```

==> serverspec_sample 주석해제가 되어있지 않아서 test 케이스가 새로 생성되지 않았고,

그 전에 만들어져 있던걸로 계속 실행중이엇다!!



> #### 해결법 



```
# 바뀐 부분은 여기뿐...!
[vagrant@demo localhost]$ [vagrant@demo localhost]$ pwd
/tmp/serverspec_sample/spec/localhost
[vagrant@demo localhost]$ ls -l
total 4
-rw-r--r--. 1 root root 397 Sep 11 08:33 web_spec.rb
```





> /home/vagrant/ansible-playbook-sample   vs   /tmp/ansible-playbook-sample 차이

===> /home/vagrant/ansible-playbook-sample 이건 2장 실습한 경로..

===> /tmp/ansible-playbook-sample 이건 3장 실습한 경로...

똑같은 파일 & 단지 경로만 다른것 뿐!  & 원하면 /home/vagrant/ansible-playbook-sample 파일로 실습가능





ansible을 돌림 -> serverspec 설치되어있으면 pass -> serverspec_sample 디렉토리 있으면 pass

-> spec file 수정!

