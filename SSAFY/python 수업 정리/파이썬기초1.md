# Python 기초1

## 1. 기초 문법(Syntax)

### 주석(Comment)

```python
# 한 줄 주석
# 여러줄 코드 주석은
# 기본적으로 한 줄 주석으로 사용한다

"""
멀티라인으로 주석처리 가능하나,
주로 함수/클래스 설명시에 사용한다
"""
```

<br>

### 코드 라인

```python
print('파이썬은')
print('1줄에 1문장이 원칙이다')
print("""내용이 길어서 여러줄 사용시에는
다음과 같이 작성하는게 관례이다""")

sample_list = [
    '리스트는','이렇게'
    '여러줄','사용가능'
]

sample_dict = {
    'dict도':0,
    '여러줄':'ok'
}
```

<br>

### 변수(Variable)

#### - 할당 연산자(Assignment Operator)  `=`

```python
# 변수 a에 60 할당
a = 60
# type() : 해당 변수의 데이터 타입 확인
print(type(a))  # <class 'int'>
# id() : 해당 변수의 메모리 주소 확인
print(id(a)) # 140721662070288
# help() : 도움말 보여준다
print(help(int)) # int에 대한 설명 확인
```

같은 값 동시에 할당 가능 & 동시에 두개 할당 가능

(하지만 추천하지 않는다...가독성이 떨어지기 때문에 1줄 1할당 추천!)

```python
x = y = 10
print(x, y) # 10 10
x, y = 1, 10
print(x, y) # 1 10
```

> 변수의 값 바꾸기(swaping)
>
> ```python
> x = 10
> y = 100
> x, y = y, x
> print(x, y) # 100 10
> ```

#### - 식별자(Identifiers)

- 영문 알파벳, 밑줄(_), 숫자로 구성

- 첫 글자에 숫자 X

- 길이에 제한 X

- 대소문자 구별한다

- 예약어 사용 X

  ```python
  import keyword
  print(keyword.kwlist)
  # ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
  ```

<br>

### 데이터 타입(Data Type)

#### 1. 숫자(Number) 타입

#### - 정수(Integer) `int`

- 파이썬 3.x 버전 이후 `long`타입 없이 `int`타입으로 표기

- 8진수 : `0o`/ 2진수: `0b`/ 16진수: `0x`로 표현 가능

  ```python
  binary_number = 0b10
  octal_number = 0o10
  decimal_number = 10
  hexadecimal_number = 0x10
  print(f"""
  2진수 : {binary_number}
  8진수 : {octal_number}
  10진수 : {decimal_number}
  16진수 : {hexadecimal_number}
  """)
  
  # 2진수 : 2
  # 8진수 : 8
  # 10진수 : 10
  # 16진수 : 16
  ```

> 파이썬에서 표현가능한 가장 큰 수
>
> ```python
> import sys
> max_int = sys.maxsize
> # sys.maxsize 의 값은 2**63 - 1 => 64비트에서 부호비트를 뺀 63개의 최대치
> print(max_int) # 9223372036854775807
> super_max = sys.maxsize * sys.maxsize
> print(super_max) # 85070591730234615847396907784232501249
> ```
>
> 파이썬은 정수 자료형(Integer)에서 오버플로우가 없다
>
> 그 이유는 임의 정밀도 산술을 사용하기 때문이다
>
> - 오버 플로우**(overflow)**
>
>   표현 가능 범위 넘어가면 기대했던 값이 나오지 않는 현상
>
>   즉, 메모리가 차고 넘쳐 흐르는 현상
>
> - 임의 정밀도 산술**(arbitrary-precision arithmetic)**
>
>   가용 메모리를 모두 수 표현에 끌어다 쓸 수 있는 형태
>
>   즉, 4바이트가 수 표현에 부족하면 5,6바이트 사용하게 유동적으로 운용

#### - 부동소수점, 실수(floating point number) `float`

실수를 표현하는 과정에서 부동소수점을 사용하며<br>항상 같은 값으로 일치하지 않는다(floating point rounding error)

```python
# 컴퓨터식 지수 표현 방식을 사용 (e, E 둘다 사용가능)
# 314 에서 소수점 앞으로 2자리 이동 => 3.14
pi = 314e-2
print(pi, type(pi)) # 3.14 <class 'float'>
```

실수의 연산 값 처리는 조심해야 한다

```python
print(3.5 - 3.12) # 0.3799999999999999
# round() 반올림 함수 사용
round(3.5 - 3.12, 2) # 0.38
# 두 개의 값이 같지 않다
print(3.5 - 3.12 == 0.38) # False
```

**===> 다음과 같이 처리 가능하다**

```python
# 1. 기본적인 처리방법
a = 3.5 - 3.12
b = 0.38

print(abs(a - b) <= 1e-10) # True

# 2. sys 모듈을 통해 처리
import sys
print(abs(a - b) <= sys.float_info.epsilon) # True

# 3. math 모듈 사용해서 처리
import math
print(math.isclose(a, b)) # True
```

#### - 복소수(complex number) `complex`

```python
a = 3 - 4j
a = complex('3-4j')
# 문자열을 변환할 때, 문자열은 중앙의 + 또는 - 연산자 주위에 공백X
a = complex('3 - 4j') # ValueError
# 실수부= a.real , 허수부= a.imag
print(a.real, a.imag) # 3.0 -4.0
```

<br>

#### 2. 문자(String) 타입

'' 이걸로 결정했으면 끝까지 작은 따옴표로 사용<br>"" 이걸로 결정했으면 끝까지 큰 따옴표로 사용

```python
sample = '문자열1'
sample = "문자열2"
sample = "'안에 담을 수도 있다'"
# 동일따옴표 사용시 '이렇게
sample = '동일따옴표 사용시 \'이렇게' 
sample = """여러 줄은
이렇게 표현"""
sample = '''이렇게도 
여러줄 가능'''
```

사용자에게 받은 입력은 기본적으로 str이다

```python
name = input() # 1
print(name, type(name)) # 1 <class 'str'>
```

문자열은 + 붙이기 , * 로 반복가능

```python
print('hi' * 10) # 'hihihihihihihihihihi'
print('hi' + 'hong') # 'hihong'

a = 'hi'
b = ', hong'
print(a + b) # 'hi, hong'
```

#### 이스케이프 시퀀스

| <center>예약문자</center> |    내용(의미)     |
| :-----------------------: | :---------------: |
|            \n             |      줄 바꿈      |
|            \t             |        탭         |
|            \r             |    캐리지리턴     |
|            \0             |     널(Null)      |
|           \\\\            |        `\`        |
|            \\'            | 단일인용부호(`'`) |
|            \\"            | 이중인용부호(`"`) |

```python
# 개행 문자 말고도 가능합니다!진짜로!알고보면 print는 기본이 \n!
print('개행 문자 말고도 가능합니다', end='!')
print('진짜로', end='!')
print('알고보면 print는 기본이 \\n', end='!')
```

#### String interpolation

interpolation에서 출력형식을 지정할 수 있습니다.

https://docs.python.org/ko/3/library/datetime.html#strftime-and-strptime-format-codes

```python
name = 'Kim'
score = 4.5

# str.format()
# Hello, Kim. 내 성적은 4.5
print('Hello, {}. 내 성적은 {}'.format(name, score))

# f-string을 활용 파이썬 3.6 이상에서 사용가능
# 
# Hello,
# Kim
print(f"""
Hello,
{name}
""")
```

형식 지정 또는 연산/출력형식 지정도 가능하다

```python
import datetime
today = datetime.datetime.now()
print(today) # 2021-01-18 10:28:01.178706
# 오늘은 21년 01월 18일 Monday
print(f'오늘은 {today:%y}년 {today:%m}월 {today:%d}일 {today:%A}')

pi = 3.141592
# 원주율은 3.142! 반지름이 2일때 원의 넓이는 12.566368
print(f'원주율은 {pi:.4}! 반지름이 2일때 원의 넓이는 {pi*2*2}')
```

<br>

#### 3. 참/거짓(Boolean) 타입

다음음 모두 **False** 이다! (**빈 배열 또는 0 None 값**)

```
0, 0.0, (), [], {}, '', None
```

```python
print(bool(0)) # False
print(bool(0.1)) # True
print(bool([])) # False
print(bool({})) # False
print(bool(None)) # False
print(bool('')) # False
print(bool('0')) # True
```

`None`타입 :  값이 없음을 표현함

```python
print(type(None)) # <class 'NoneType'>

a = None
print(a) # None
```

<br>

#### 4. 형변환(Type conversion, Typecasting)

- 암시적 형변환(Implicit Type Conversion) : 자동으로 형변환 

  - bool
  - Numbers (int, float, complex)

  ```python
  # True 값을 int 1로 형변환 => 6 출력
  print(True + 5) 
  
  int_number = 3
  float_number = 5.0
  complex_number = 3+5j
  
  result = int_number + float_number
  print(result, type(result)) # 8.0 <class 'float'>
  
  result = int_number + complex_number
  print(result, type(result)) # (6+5j) <class 'complex'>
  ```

- 명시적 형변환(Explicit Type Conversion)

  - string -> intger : 형식에 맞는 숫자만 가능
  - integer -> string : 모두 가능
  - **위의 상황 제외**하고 모두 명시적 형변환 해야 한다

  ```python
  print(1 + '등') # TypeError
  print(str(1) + '등') # 1등
  
  a = '3.5'
  int(a) # 3.5를 int로 변환X -> ValueError
  a = 3.5
  int(a) # 3
  ```

<br>

### 연산자(Operator)

#### 1. 산술 연산자

| 연산자 | 내용           |
| ------ | -------------- |
| +      | 덧셈           |
| -      | 뺄셈           |
| \*     | 곱셈           |
| /      | 나눗셈         |
| //     | 몫             |
| %      | 나머지(modulo) |
| \*\*   | 거듭제곱       |

- 나눗셈 (`/`) 은 항상 float를 돌려준다.
- 정수 나눗셈 으로 (소수부 없이) 정수 결과를 얻으려면 `//` 연산자를 사용한다.

**divmod** : 몫과 나머지 리턴하는 함수

```python
quotient, remainder = divmod(5, 2)
# 몫은 2, 나머지는 1
print(f'몫은 {quotient}, 나머지는 {remainder}')
```

#### 2. 비교 연산자

| 연산자   | 내용                   |
| -------- | ---------------------- |
| `<`      | 미만                   |
| `<=`     | 이하                   |
| `>`      | 초과                   |
| `>=`     | 이상                   |
| `==`     | 같음                   |
| `!=`     | 같지않음               |
| `is`     | 객체 아이덴티티        |
| `is not` | 부정된 객체 아이덴티티 |

#### 3. 논리 연산자

| 연산자  | 내용                         |
| ------- | ---------------------------- |
| a and b | a와 b 모두 True시만 True     |
| a or b  | a 와 b 모두 False시만 False  |
| not a   | True -> False, False -> True |

```python
# and
print(True and True) # True
print(True and False) # False
print(False and True) # False
print(False and False) # False
# or
print(True or True) # True
print(True or False) # True
print(False or True) # True
print(False or False) # False
# not
print(not True) # False
print(not 0) # True
```

- 파이썬에서 **and는 a가 거짓이면 a를 리턴하고, 참이면 b를 리턴**한다.
- 파이썬에서 **or은 a가 참이면 a를 리턴하고, 거짓이면 b를 리턴**한다.

```python
# a : True이다
# and는 뒤에 오는 값도 True여야 True이므로 뒷값도 확인해야한다
# b : True이다
# 따라서 b 값도 확인했기 때문에 b가 리턴된다
print('a' and 'b') # b

# a : True이다
# or 뒤에 오는 값에 관계없이 True이다
# 따라서 b 값 확인할 필요없기 때문에 a가 리턴된다
print('a' or 'b') # a

vowels = 'aeiou'
# 괄호 먼저 계산
# ('a' and 'b') 는 b 이므로
# 'b' in vowels 와 같은의미 ==> False
print(('a' and 'b') in vowels) # False
# 괄호 먼저 계산
# ('b' and 'a') 는 a 이므로
# 'a' in vowels 와 같은의미 ==> True
print(('b' and 'a') in vowels) # True

# 3 확인 후 5도 확인 필요 => True이므로 5 리턴
print(3 and 5)
# 3 확인 후 0도 확인 필요 => False이므로 0 리턴
print(3 and 0)
# 0 확인 후 3 확인 필요X => False이므로 0 리턴
print(0 and 3)
# 0 확인 후 0 확인 필요X => False이므로 0 리턴
print(0 and 0)

# 3 확인 후 5 확인 필요X => True이므로 3 리턴
print(3 or 5)
# 3 확인 후 0 확인 필요X => True이므로 3 리턴
print(3 or 0)
# 0 확인 후 3도 확인 필요 => True이므로 3 리턴
print(0 or 3)
# 0 확인 후 0도 확인 필요 => False이므로 0 리턴
print(0 or 0)
```

#### 4. 복합 연산자

| 연산자    | 내용       |
| --------- | ---------- |
| a += b    | a = a + b  |
| a -= b    | a = a - b  |
| a \*= b   | a = a \* b |
| a /= b    | a = a / b  |
| a //= b   | a = a // b |
| a %= b    | a = a % b  |
| a \*\*= b | a = a ** b |

#### 5. 기타 주요 연산자

숫자가 아닌 자료형은 `+` 연산자를 통해 합칠 수 있다

```python
print('abc' + 'efg') # abcefg
print([1, 2, 3] + [4, 5, 6]) # [1, 2, 3, 4, 5, 6]
```

`in` 연산자를 통해 요소가 속해있는지 여부를 확인

```python
print('a' in 'apple') # True
print(1 in [1, 2, 3]) # True
print(100 in range(1, 5)) # False
```

`is` 연산자를 통해 동일한 object인지 확인

**리스트, 딕셔너리 등은 [] 빈 배열이어도 id 주소값이 다 다르다**

```python
a = []
b = []
# 값을 비교하면, 빈 리스트라서 같은데
# is를 통해서 object, 다르다..
print(a == b, a is b) # True False
print(id(a), id(b)) # 2176949362560 2176949327168
```

**0 ~ 256 까지의 숫자는 주소가 캐시화 되어 있어서 주소값이 항상 같다**<br>257 이후는 보장할 수 없다

```python
# 의도적으로 특정 범위의 숫자를 id를 같게끔 해놨다.
a = 1
b = 1
print(a is b)
print(id(a), id(b)) # 140730894124704 140730894124704

# 257 이후의 id는 같다고 보장할 수 없다
a = 1004
b = 1004
print(a is b) # False 
print(id(a), id(b)) # 2176950300784 2176950301424
```

**공백 없는 알파벳 문자열도 id 주소가 동일하다**

```python
# object interning..
# 의도적으로.. 공백없는 알파벳 문자열도 같게끔 해놨다.
a = 'hi'
b = 'hi'
print(a is b) # True
print(id(a), id(b)) # 2176910051888 2176910051888
```

**Indexing/Slicing [시작인덱스 포함: 종료인덱스 미포함]** 

```python
# indexing
a = 'samsung'
print(a[0]) # s
print(a[0:2]) # sa
```

#### 6. 연산자 우선순위

1. `()`을 통한 grouping
2. Slicing
3. Indexing
4. 제곱연산자 `**`
5. 단항연산자 `+`, `-` (음수/양수 부호)
6. 산술연산자 `*`, `/`, `%`
7. 산술연산자 `+`, `-`
8. 비교연산자, `in`, `is`
9. `not`
10. `and`
11. `or`



## 참고 : 표현식(Expression) & 문장(Statement)

### 표현식(Expression)

> 표현식 => `evaluate` => 값

- 하나의 값(value)으로 환원(reduce)될 수 있는 문장
- `식별자`, `값`(리터럴), `연산자`로 구성됩니다.
- 표현식을 만드는 문법(syntax)은 일반적인 (중위표기) 수식의 규칙과 유사

```python
# 표현식은 하나의 값으로 평가(evaluate)될 수 있어야 한다. 
radius = 10
# 식별자가 값이 할당되어 있는 경우 수식의 일부가 될 수 있다.
print(3.14 * (radius - 5) ** 2)
```

### 문장(Statement)

파이썬이 실행 가능한 최소한의 코드 단위(a syntatic unit of programming)

```python
# 하나의 값(value)도 문장이 될 수 있습니다.
print('ssafy')
# 표현식(expression)도 문장이 될 수 있습니다.
print(5 * 21 - 4)
```

![](https://user-images.githubusercontent.com/9452521/87619771-f41f5e00-c757-11ea-9e4b-1f76e4ca0981.png)

![](https://user-images.githubusercontent.com/9452521/87640197-55a7f280-c781-11ea-9cff-19c022ce704a.png)